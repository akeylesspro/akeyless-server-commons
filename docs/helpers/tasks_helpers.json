{
  "metadata": {
    "source_file": "src/helpers/tasks_helpers.ts",
    "path": "docs/helpers/tasks_helpers.md",
    "type": "module"
  },
  "purpose": "Task execution orchestration with status tracking, result caching, and optional persistence to Firestore or Firebase Storage. Designed for scheduled/recurring backend tasks that need to track execution status, cache results, and optionally persist large datasets.",
  "dependencies": [
    "cache_manager - In-memory cache for task results",
    "logger - Logging utility",
    "set_document from firebase_helpers - Updates task status in Firestore",
    "get_document_by_id_optional from firebase_helpers - Retrieves task data",
    "Firebase Admin storage - File storage for large datasets",
    "TObject from akeyless-types-commons - Generic object type",
    "performance - Performance timing API"
  ],
  "sections": [
    {
      "title": "Enums and Types",
      "type_definitions": [
        {
          "name": "TaskName",
          "type": "enum",
          "definition": "enum TaskName {\n  send_reset_sms = \"send_reset_sms\",\n  collect_devices_health = \"collect_devices_health\",\n  collect_charge_locations = \"collect_charge_locations\",\n  collect_charge_cdrs = \"collect_charge_cdrs\"\n}",
          "description": "Predefined task names for type safety",
          "values": [
            "send_reset_sms",
            "collect_devices_health",
            "collect_charge_locations",
            "collect_charge_cdrs"
          ]
        },
        {
          "name": "TaskStatus",
          "type": "enum",
          "definition": "enum TaskStatus {\n  running = \"running\",\n  completed = \"completed\",\n  failed = \"failed\",\n  suspeneded = \"suspeneded\"\n}",
          "description": "Task execution status values",
          "values": [
            "running",
            "completed",
            "failed",
            "suspeneded"
          ]
        },
        {
          "name": "TaskSaveOptions",
          "type": "type",
          "definition": "type TaskSaveOptions = \"storage\" | \"db\" | \"none\";",
          "description": "Where to save task results: \"storage\" - Save to Firebase Storage (for large datasets), \"db\" - Save to Firestore document (for small datasets), \"none\" - Don't save data, only cache"
        }
      ]
    },
    {
      "title": "Task Execution",
      "exports": [
        {
          "name": "execute_task",
          "signature": "execute_task<T = any>(source: string, task_name: TaskName, task: () => Promise<T>, options?: ExecuteTaskOptions): Promise<void>",
          "type": "function",
          "description": "Executes a task function with status tracking and result persistence.",
          "parameters": [
            {
              "name": "source",
              "type": "string",
              "description": "Source identifier (e.g., service name, scheduler name)"
            },
            {
              "name": "task_name",
              "type": "TaskName",
              "description": "Task name from TaskName enum"
            },
            {
              "name": "task",
              "type": "() => Promise<T>",
              "description": "Async function that performs the actual work"
            },
            {
              "name": "options",
              "type": "ExecuteTaskOptions",
              "optional": true,
              "description": "Optional configuration: save_in (\"storage\" | \"db\" | \"none\"), debug_logs (default: true)"
            }
          ],
          "returns": "Promise resolving when task completes (or fails)",
          "behavior": [
            "Initial Status: Writes task document to nx-tasks collection with source, status: TaskStatus.running, started: new Date(), timestamp: new Date(), error: \"\", Uses merge: false to overwrite previous status",
            "Task Execution: Logs task start (if debug_logs is true), Records start time using performance.now(), Executes task function, Records execution duration",
            "Success Handling: Updates task document with status: TaskStatus.completed, completed: new Date(), timestamp: new Date(), Data Saving (based on save_in): \"none\": Sets data: \"no data to save\", \"storage\": Saves data to cache, Uploads to Firebase Storage via keep_task_data_in_storage, Sets data to signed URL, \"db\" or undefined: Saves data to cache, Sets data to actual data object, Logs completion with duration (if debug_logs is true)",
            "Error Handling: Catches exceptions, Normalizes error (extracts message from Error instances), Updates task document with status: TaskStatus.failed, completed: new Date(), timestamp: new Date(), error - Error message, Logs error"
          ],
          "examples": [
            {
              "code": "// Save to Firestore\nawait execute_task(\n  'scheduler',\n  TaskName.collect_devices_health,\n  async () => {\n    const devices = await fetchDevices();\n    return devices.map(d => ({ id: d.id, health: d.health }));\n  },\n  { save_in: 'db', debug_logs: true }\n);\n\n// Save to Storage (for large datasets)\nawait execute_task(\n  'scheduler',\n  TaskName.collect_charge_cdrs,\n  async () => {\n    return await fetchLargeDataset(); // Returns large array\n  },\n  { save_in: 'storage' }\n);",
              "language": "typescript"
            }
          ]
        }
      ]
    },
    {
      "title": "Task Data Retrieval",
      "exports": [
        {
          "name": "get_task_data",
          "signature": "get_task_data<T = any>(task_name: TaskName): Promise<T>",
          "type": "function",
          "description": "Retrieves task result data with caching and fallback logic.",
          "parameters": [
            {
              "name": "task_name",
              "type": "TaskName",
              "description": "Task name from TaskName enum"
            }
          ],
          "returns": "Promise resolving to task data (array or object)",
          "behavior": [
            "Cache Check: Checks cache_manager for array data, Checks cache_manager for object data, Returns cached data if found",
            "Firestore Fallback: Retrieves task document from nx-tasks collection, Checks data field: If string starting with \"http\" → treats as Storage URL, If object → uses directly, Otherwise → returns empty array",
            "Storage Fallback: If data is Storage URL, downloads file via get_task_data_from_storage, Parses JSON content, Caches result, Returns data",
            "Caching: Caches all retrieved data for future access, Uses appropriate cache method (array or object) based on data type"
          ],
          "returns": "Empty array [] if no data found",
          "examples": [
            {
              "code": "// Get cached or stored task data\nconst healthData = await get_task_data(TaskName.collect_devices_health);\n// Returns: Array of device health objects or []\n\n// Use the data\nif (healthData.length > 0) {\n  const unhealthy = healthData.filter(d => d.health === 'unhealthy');\n}",
              "language": "typescript"
            }
          ]
        }
      ]
    },
    {
      "title": "Storage Helpers",
      "exports": [
        {
          "name": "get_task_data_from_storage",
          "signature": "get_task_data_from_storage<T = any>(task_name: TaskName): Promise<T | null>",
          "type": "function",
          "description": "Downloads and parses task data from Firebase Storage.",
          "parameters": [
            {
              "name": "task_name",
              "type": "TaskName",
              "description": "Task name from TaskName enum"
            }
          ],
          "returns": "Promise resolving to parsed data or null if file doesn't exist",
          "behavior": [
            "Constructs file path: tasks_data/{task_name}.json",
            "Downloads file from Firebase Storage bucket",
            "Parses JSON content",
            "Returns parsed data"
          ],
          "error_handling": [
            "Returns null if file doesn't exist or download fails",
            "Logs errors"
          ],
          "examples": [
            {
              "code": "const data = await get_task_data_from_storage(TaskName.collect_charge_cdrs);\nif (data) {\n  console.log(`Loaded ${data.length} records`);\n}",
              "language": "typescript"
            }
          ]
        },
        {
          "name": "keep_task_data_in_storage",
          "signature": "keep_task_data_in_storage(task_name: TaskName, data: any[] | TObject<any>): Promise<string>",
          "type": "function",
          "description": "Uploads task data to Firebase Storage and returns signed URL.",
          "parameters": [
            {
              "name": "task_name",
              "type": "TaskName",
              "description": "Task name from TaskName enum"
            },
            {
              "name": "data",
              "type": "any[] | TObject<any>",
              "description": "Data to save (array or object)"
            }
          ],
          "returns": "Promise resolving to signed URL (valid for 7 days)",
          "behavior": [
            "Validates data is object or array (throws if not)",
            "Constructs file path: tasks_data/{task_name}.json",
            "Stringifies data as JSON",
            "Uploads to Firebase Storage with content type application/json",
            "Generates signed URL (7-day expiration)",
            "Returns signed URL"
          ],
          "throws": "Error if data is not object/array or upload fails",
          "examples": [
            {
              "code": "const url = await keep_task_data_in_storage(\n  TaskName.collect_devices_health,\n  [{ id: '1', health: 'good' }, { id: '2', health: 'bad' }]\n);\n// Returns: 'https://storage.googleapis.com/.../tasks_data/collect_devices_health.json?...'",
              "language": "typescript"
            }
          ]
        }
      ]
    }
  ],
  "context": [
    "This module provides a complete task execution framework:",
    "Status Tracking - Monitor task execution in real-time",
    "Result Caching - Fast access to task results via cache",
    "Flexible Persistence - Choose storage location based on data size",
    "Error Handling - Comprehensive error tracking and logging",
    "Performance Monitoring - Execution time tracking"
  ],
  "best_practices": [
    "Use TaskName enum for type safety",
    "Use \"storage\" for large datasets (>1MB)",
    "Use \"db\" for small datasets (<100KB)",
    "Use \"none\" for tasks that don't produce data",
    "Check task status before executing (avoid concurrent runs)",
    "Use get_task_data to access cached results efficiently"
  ]
}
