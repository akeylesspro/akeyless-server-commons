<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>src/middlewares/error_handling.ts</title>
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body>
    <div class="content">
    <h1>src/middlewares/error_handling.ts</h1>
    <h2>Purpose</h2>
    <p>Provides error handling utilities for Express applications, including an async error wrapper and a global error handler middleware. Ensures that asynchronous errors in route handlers are properly caught and handled by Express's error handling system.</p>

    <h2>Dependencies</h2>
    <ul>
      <li><strong>Managers:</strong>
        <ul>
          <li><a href="../managers/logger_manager.html"><code>logger</code></a> - Logging manager for error tracking and stack trace logging</li>
        </ul>
      </li>
      <li><strong>Types:</strong>
        <ul>
          <li><a href="../types/types/global.html"><code>Service</code></a> - Type definition for async route handler functions</li>
        </ul>
      </li>
      <li><strong>Express Types:</strong>
        <ul>
          <li><code>Request</code>, <code>Response</code>, <code>NextFunction</code> - Standard Express types</li>
        </ul>
      </li>
    </ul>

    <h2>Exports</h2>

    <h3><code>async_error_handler(service: Service)</code></h3>
    <p>A higher-order function that wraps async route handlers to automatically catch and forward Promise rejections to Express's error handling middleware.</p>
    <p><strong>Parameters:</strong></p>
    <ul>
      <li><code>service: Service</code> - An async function that takes <code>(req: Request, res: Response)</code> and returns a Promise</li>
    </ul>
    <p><strong>Returns:</strong> Express middleware function <code>(req: Request, res: Response, next: NextFunction) => void</code></p>
    <p><strong>Behavior:</strong></p>
    <ul>
      <li>Wraps the provided service function in a Promise.resolve() call</li>
      <li>If the service resolves successfully, the middleware chain continues normally</li>
      <li>If the service rejects (throws an error or returns a rejected Promise), the error is caught and passed to Express's error handling middleware via <code>next(error)</code></li>
      <li>This allows async route handlers to throw errors naturally without needing try-catch blocks, as Express will route them to the global error handler</li>
    </ul>
    <p><strong>Usage:</strong></p>
    <pre><code>// Without wrapper (errors might not be caught)
app.get('/route', async (req, res) => {
  const data = await someAsyncOperation(); // Error here might not be handled
  res.json(data);
});

// With wrapper (errors are properly caught)
app.get('/route', async_error_handler(async (req, res) => {
  const data = await someAsyncOperation(); // Error here is caught and forwarded
  res.json(data);
}));</code></pre>
    <p><strong>Implementation Details:</strong> Uses <code>Promise.resolve(service(req, res))</code> to ensure the service result is always a Promise, then calls <code>.catch(next)</code> to forward any rejection to Express error handling.</p>

    <h3><code>error_handler(err: Error, req: Request, res: Response, next: NextFunction)</code></h3>
    <p>Global Express error handler middleware that catches all errors in the middleware chain and returns a standardized error response.</p>
    <p><strong>Parameters:</strong></p>
    <ul>
      <li><code>err: Error</code> - The error object that was thrown or passed via <code>next(error)</code></li>
      <li><code>req: Request</code> - Express request object</li>
      <li><code>res: Response</code> - Express response object</li>
      <li><code>next: NextFunction</code> - Express next function (not used, but required by Express error handler signature)</li>
    </ul>
    <p><strong>Behavior:</strong></p>
    <ul>
      <li>Logs the error stack trace using <code>logger.error("Global Error Handler:", err.stack)</code></li>
      <li>Returns an HTTP 500 (Internal Server Error) status code</li>
      <li>Sends a JSON response with standardized error format:
        <pre><code>{
  status: "error",
  message: err.message || "Internal Server Error"
}</code></pre>
      </li>
      <li>If the error object doesn't have a <code>message</code> property, defaults to "Internal Server Error"</li>
    </ul>
    <p><strong>Usage:</strong></p>
    <pre><code>// Register as the last middleware (after all routes)
app.use(error_handler);

// Errors from any middleware or route will be caught here
app.get('/route', async_error_handler(async (req, res) => {
  throw new Error('Something went wrong'); // Caught by error_handler
}));</code></pre>

    <h2>Context</h2>
    <p>These error handling utilities are essential for:</p>
    <ul>
      <li><strong>Async Route Safety</strong> - <code>async_error_handler</code> ensures that async/await errors in route handlers don't crash the server and are properly handled</li>
      <li><strong>Centralized Error Handling</strong> - <code>error_handler</code> provides a single point for error logging and response formatting</li>
      <li><strong>Server Bootstrap</strong> - Used by the server initialization code to standardize error handling across all routes</li>
      <li><strong>Consistent Error Responses</strong> - All errors return the same JSON format, making it easier for clients to handle errors</li>
    </ul>

    <h2>Integration Pattern</h2>
    <p>The typical pattern for using these utilities:</p>
    <pre><code>import { async_error_handler, error_handler } from './middlewares/error_handling';

// Wrap async routes
app.get('/api/data', async_error_handler(async (req, res) => {
  const data = await fetchData();
  res.json({ success: true, data });
}));

// Register global error handler last
app.use(error_handler);</code></pre>

    <h2>Best Practices</h2>
    <ul>
      <li>Always use <code>async_error_handler</code> for async route handlers to ensure errors are caught</li>
      <li>Register <code>error_handler</code> last in the middleware chain, after all routes</li>
      <li>Use descriptive error messages so they're useful in logs and client responses</li>
      <li>Don't call <code>next()</code> after sending a response - the error handler will handle it</li>
    </ul>

    <h2>Error Flow</h2>
    <ol>
      <li>Route handler throws error or returns rejected Promise</li>
      <li><code>async_error_handler</code> catches the error and calls <code>next(error)</code></li>
      <li>Express routes the error to error handling middleware</li>
      <li><code>error_handler</code> logs the error and sends standardized response</li>
      <li>Client receives 500 status with error message</li>
    </ol>
    </div>
  </body>
</html>
